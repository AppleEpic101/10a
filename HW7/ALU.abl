MODULE      ALU 

INTERFACE  (Data7..Data0,
            LSR, ASR, ROR, RRC, ROL, RLC, ASL,
            ADD, ADC, SBB, SUB, CMP, INC, DEC,
            AND, OR, XOR, NOT, TST,
            Reset, Clock
            -> Accum7..Accum0, Zero, Sign, Overflow, CarryFlag);

TITLE      'Caltech10 ALU Unit'

" Pin/Signal Declarations
Data7..Data0    pin;                " 8-bit data input
LSR, ASR, ROR, RRC, ROL, RLC, ASL pin;
ADD, ADC, SBB, SUB, CMP, INC, DEC pin;
AND, OR, XOR, NOT, TST            pin;
Reset, Clock                      pin;

Accum7..Accum0  pin istype 'reg';   " 8-bit Accumulator
Zero, Sign, Overflow, CarryFlag pin istype 'com'; " Status Outputs

" --- Internal Nodes ---
Flags7..Flags0      node istype 'reg';  " 8-bit Status Register
Sum8..Sum0          node istype 'com';
ALUOut7..ALUOut0    node istype 'com';
LogicOut7..LogicOut0 node istype 'com';
ShiftOut7..ShiftOut0 node istype 'com';
AdderA7..AdderA0    node istype 'com';
AdderB7..AdderB0    node istype 'com';
CarryIn, Cout       node istype 'com';
Arithmetic, Shift   node istype 'com';
LogicInst           node istype 'com';
UpdatingAcc         node istype 'com';
UpdatingFlags       node istype 'com';
NewS, NewZ, NewC, NewV node istype 'com';
IsSub, ArithmeticC, ArithmeticV node istype 'com';

" --- Sets & Macros ---
Sum      = [Sum8..Sum0];
ALUOut   = [ALUOut7..ALUOut0];
LogicOut = [LogicOut7..LogicOut0];
ShiftOut = [ShiftOut7..ShiftOut0];
AdderA   = [AdderA7..AdderA0];
AdderB   = [AdderB7..AdderB0];
LSL      = ASL;
POPF, CLC, STC = [0, 0, 0]; " Not used in current demo, set to 0
NEG      = 0;               " Not used in current demo, set to 0

" --- Flag Mapping ---
C = Flags3; 
V = Flags2;
S = Flags1;
Z = Flags0;

" --- Adder Logic ---
" Sum = [0, AdderA] + [0, AdderB] + CarryIn
" AdderA is usually the accumulator. For NEG, it is 0
AdderA = (ADD # ADC # SUB # SBB # CMP # LSL # ROL # RLC # INC # DEC) & [Accum7..Accum0]
       # (NEG) & 0;

AdderB = (ADD # ADC) & [Data7..Data0]
       # (SUB # SBB # CMP) & ![Data7..Data0]
       # (LSL # ROL # RLC) & [Accum7..Accum0]
       # (INC) & 0
       # (DEC) & ^hFF
       # (NEG) & ![Accum7..Accum0];

" 4 possible Carry In values
CarryIn = (ADC & C)
        # (SUB # CMP # INC # NEG) & 1
        # (SBB & C)
        # (RLC & C);

" 9-bit Addition
Sum = [0, AdderA] + [0, AdderB] + CarryIn;
Cout = Sum8;

" --- Shifter & Logic ---
ShiftOut = (LSR) & [0, Accum7..Accum1]
         # (ASR) & [Accum7, Accum7..Accum1]
         # (ROR) & [Accum0, Accum7..Accum1]
         # (RRC) & [C, Accum7..Accum1];

LogicOut = (AND # TST) & ([Accum7..Accum0] & [Data7..Data0])
         # (OR)        & ([Accum7..Accum0] # [Data7..Data0])
         # (XOR)       & ([Accum7..Accum0] $ [Data7..Data0])
         # (NOT)       & ![Accum7..Accum0];

" --- ALU Output Selection ---
ALUOut = (ADD # ADC # SUB # SBB # INC # DEC # NEG # CMP # LSL # ROL # RLC) & [Sum7..Sum0]
       # (AND # OR # XOR # NOT # TST) & LogicOut
       # (LSR # ASR # ROR # RRC) & ShiftOut;

" --- Update Control ---
Arithmetic = ADD # ADC # SUB # SBB # INC # DEC # NEG # CMP;
Shift      = LSL # LSR # ASR # ROL # ROR # RLC # RRC;
LogicInst  = AND # OR # XOR # NOT # TST;

UpdatingAcc   = (ADD # ADC # SUB # SBB # INC # DEC # NEG # AND # OR # XOR # NOT # Shift) & !CMP & !TST;
UpdatingFlags = Arithmetic # Shift # LogicInst # CLC # STC;

EQUATIONS

" --- Accumulator Register ---
[Accum7..Accum0].clk  = Clock;
[Accum7..Accum0].aclr = Reset;
WHEN UpdatingAcc THEN [Accum7..Accum0].d = ALUOut;
ELSE [Accum7..Accum0].d = [Accum7..Accum0];

" --- Status Register (Flags) ---
[Flags7..Flags0].clk  = Clock;
[Flags7..Flags0].aclr = Reset;

" S and Z are affected by all ALU operations 
NewS = ALUOut7;
NewZ = (ALUOut == 0);

" C Flag: Inverted for Subtraction/Compare
IsSub = SUB # SBB # CMP # NEG # DEC;
ArithmeticC = (IsSub & !Cout) # (!IsSub & Cout);

NewC = (Arithmetic & ArithmeticC)
     # ((LSL # ROL # RLC) & Cout)
     # ((LSR # ASR # ROR # RRC) & Accum0)
     # (STC & 1)
     # (CLC & 0)
     # (LogicInst & C); " Unchanged for logic

" V Flag: Overflow 
" Right shifts always clear V
ArithmeticV = (AdderA7 == AdderB7) & (ALUOut7 != AdderA7);

NewV = (Arithmetic & ArithmeticV)
     # ((LSL # ROL # RLC) & (ALUOut7 != Accum7))
     # ((LSR # ASR # ROR # RRC) & 0) 
     # (LogicInst & V); " Unchanged for logic

" --- Final Flag Assignment ---
WHEN POPF THEN [Flags7..Flags0].d = [Data7..Data0]; " Load from stack
ELSE WHEN UpdatingFlags THEN {
    Flags7.d = S;      " I-Flag preserved (assuming no interrupt logic yet)
    Flags6.d = 0;      " Unused 
    Flags5.d = 0;      " U-bit (simplified) 
    Flags4.d = 0;      " Unused 
    Flags3.d = NewC;   " Carry 
    Flags2.d = NewV;   " Overflow 
    Flags1.d = NewS;   " Sign 
    Flags0.d = NewZ;   " Zero 
}
ELSE [Flags7..Flags0].d = [Flags7..Flags0];

" --- Flag Output Connections ---
CarryFlag = C;
Overflow  = V;
Sign      = S;
Zero      = Z;

END ALU